
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples/metrics/plot_rsi.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_examples_metrics_plot_rsi.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_metrics_plot_rsi.py:


Redundancy-Synergy Index
========================

This example illustrates how to use and interpret the Redundancy-Synergy
Index (RSI).

.. GENERATED FROM PYTHON SOURCE LINES 8-17

.. code-block:: default

    import numpy as np

    from hoi.metrics import RSI
    from hoi.utils import get_nbest_mult
    from hoi.plot import plot_landscape

    import matplotlib.pyplot as plt









.. GENERATED FROM PYTHON SOURCE LINES 18-24

Definition
----------

The RSI is a multivariate measure of information capable of disentangling
whether a subset of a variable X carry either redundant or synergistic
information about a variable Y. The RSI is defined as :

.. GENERATED FROM PYTHON SOURCE LINES 26-36

.. math::
    RSI(S; Y) \equiv I(S; Y) - \sum_{x_{i}\in S} I(x_{i}; Y)

with :

.. math::
    S = x_{1}, ..., x_{n}

Positive values of RSI stand for synergy while negative values of RSI reflect
redundancy between the X and Y variables.

.. GENERATED FROM PYTHON SOURCE LINES 38-44

Simulate univariate redundancy
------------------------------

A very simple way to simulate redundancy is to observe that if a triplet of
variables :math:`X_{1}, X_{2}, X_{3}` receive a copy of a variable :math:`Y`,
we will observe redundancy between :math:`X_{1}, X_{2}, X_{3}` and :math:`Y`.

.. GENERATED FROM PYTHON SOURCE LINES 44-65

.. code-block:: default


    # lets start by simulating a variable x with 200 samples and 7 features
    x = np.random.rand(200, 7)

    # now we can also generate a univariate random variable y
    y = np.random.rand(x.shape[0])

    # we now send the variable y in the column (1, 3, 5) of x
    x[:, 1] += y
    x[:, 3] += y
    x[:, 5] += y

    # define the RSI model and launch it
    model = RSI(x, y)
    hoi = model.fit(minsize=3, maxsize=5)

    # now we can take a look at the multiplets with the highest and lowest values
    # of RSI. We will only select the multiplets of size 3 here
    df = get_nbest_mult(hoi, model=model, minsize=3, maxsize=3, n_best=3)
    print(df)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

      0%|          |  0/3 [00:00<?,       ?it/s]     33%|███▎      | RSI order 3:  1/3 [00:00<00:01,    1.80it/s]     67%|██████▋   | RSI order 4:  2/3 [00:00<00:00,    2.08it/s]    100%|██████████| RSI order 5:  3/3 [00:01<00:00,    2.07it/s]                                                                    index  order       hoi  multiplet
    0     27      3  0.005224  [2, 3, 6]
    1      4      3  0.004825  [0, 1, 6]
    2     18      3  0.004206  [1, 2, 6]
    3     17      3 -0.252503  [1, 2, 5]
    4     22      3 -0.253642  [1, 4, 5]
    5     20      3 -0.564784  [1, 3, 5]




.. GENERATED FROM PYTHON SOURCE LINES 66-68

as you see from the printed table, the multiplet with the lowest (i.e. the
most redundant multiplets) is (1, 3, 5).

.. GENERATED FROM PYTHON SOURCE LINES 70-75

Simulate multivariate redundancy
--------------------------------

In the example above, we simulated a univariate :math:`Y` variable (i.e.
single column). However, it's possible to simulate a multivariate variable.

.. GENERATED FROM PYTHON SOURCE LINES 75-97

.. code-block:: default


    # simulate x again
    x = np.random.rand(200, 7)

    # simulate a bivariate y variable
    y = np.c_[np.random.rand(x.shape[0]), np.random.rand(x.shape[0])]

    # we introduce redundancy between the triplet (1, 3, 5) and the first column of
    # Y and between (0, 2, 6) and Y
    x[:, 1] += y[:, 0]
    x[:, 3] += y[:, 0]
    x[:, 5] += y[:, 0]
    x[:, 0] += y[:, 1]
    x[:, 2] += y[:, 1]
    x[:, 6] += y[:, 1]

    # define the RSI, launch it and inspect the best multiplets
    model = RSI(x, y)
    hoi = model.fit(minsize=3, maxsize=5)
    df = get_nbest_mult(hoi, model=model, minsize=3, maxsize=3, n_best=3)
    print(df)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

      0%|          |  0/3 [00:00<?,       ?it/s]     33%|███▎      | RSI order 3:  1/3 [00:00<00:00,    3.28it/s]     67%|██████▋   | RSI order 4:  2/3 [00:00<00:00,    3.20it/s]    100%|██████████| RSI order 5:  3/3 [00:00<00:00,    3.20it/s]                                                                    index  order       hoi  multiplet
    0     32      3  0.005618  [3, 4, 6]
    1     25      3  0.005211  [2, 3, 4]
    2      9      3  0.003639  [0, 3, 4]
    3      4      3 -0.222053  [0, 1, 6]
    4     20      3 -0.465329  [1, 3, 5]
    5      8      3 -0.495865  [0, 2, 6]




.. GENERATED FROM PYTHON SOURCE LINES 98-100

This time, as expected, the two most redundant triplets are (1, 3, 5) and
(0, 2, 6)

.. GENERATED FROM PYTHON SOURCE LINES 102-109

Simulate univariate and multivariate synergy
--------------------------------------------

Lets move on to the simulation of synergy that is a bit more subtle. One way
of simulating synergy is to go the other way of redundancy, meaning we are
going to add features of x inside y. That way, we can only retrieve the Y
variable by knowing the subset of X.

.. GENERATED FROM PYTHON SOURCE LINES 109-122

.. code-block:: default


    # simulate the variable x
    x = np.random.rand(200, 7)

    # synergy between (0, 3, 5) and 5
    y = x[:, 0] + x[:, 3] + x[:, 5]

    # define the RSI, launch it and inspect the best multiplets
    model = RSI(x, y)
    hoi = model.fit(minsize=3, maxsize=5)
    df = get_nbest_mult(hoi, model=model, minsize=3, maxsize=3, n_best=3)
    print(df)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

      0%|          |  0/3 [00:00<?,       ?it/s]     33%|███▎      | RSI order 3:  1/3 [00:00<00:00,    4.09it/s]     67%|██████▋   | RSI order 4:  2/3 [00:00<00:00,    4.06it/s]    100%|██████████| RSI order 5:  3/3 [00:00<00:00,    4.09it/s]                                                                    index  order       hoi  multiplet
    0     10      3  1.588863  [0, 3, 5]
    1      1      3  0.305547  [0, 1, 3]
    2      9      3  0.302004  [0, 3, 4]
    3      6      3 -0.004108  [0, 2, 4]
    4      8      3 -0.004680  [0, 2, 6]
    5      0      3 -0.005330  [0, 1, 2]




.. GENERATED FROM PYTHON SOURCE LINES 123-126

as we can see here, the highest values of higher-order interactions
(i.e. synergy) is achieved for the multiplet (0, 3, 5). Now we can do the
same for multivariate synergy

.. GENERATED FROM PYTHON SOURCE LINES 126-143

.. code-block:: default


    # simulate the variable x
    x = np.random.rand(200, 7)

    # simulate y and introduce synergy between the subset (0, 3, 5) of x and the
    # subset (1, 2, 6)
    y = np.c_[
        x[:, 0] + x[:, 3] + x[:, 5],
        x[:, 1] + x[:, 2] + x[:, 6]
    ]

    # define the RSI, launch it and inspect the best multiplets
    model = RSI(x, y)
    hoi = model.fit(minsize=3, maxsize=5)
    df = get_nbest_mult(hoi, model=model, minsize=3, maxsize=3, n_best=3)
    print(df)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

      0%|          |  0/3 [00:00<?,       ?it/s]     33%|███▎      | RSI order 3:  1/3 [00:00<00:00,    3.78it/s]     67%|██████▋   | RSI order 4:  2/3 [00:00<00:00,    3.78it/s]    100%|██████████| RSI order 5:  3/3 [00:00<00:00,    3.75it/s]                                                                    index  order       hoi  multiplet
    0     18      3  1.622816  [1, 2, 6]
    1     10      3  1.361005  [0, 3, 5]
    2     29      3  0.258521  [2, 4, 6]
    3     13      3 -0.001921  [0, 4, 6]
    4     32      3 -0.003323  [3, 4, 6]
    5     28      3 -0.007125  [2, 4, 5]




.. GENERATED FROM PYTHON SOURCE LINES 144-147

Combining redundancy and synergy
--------------------------------


.. GENERATED FROM PYTHON SOURCE LINES 147-176

.. code-block:: default


    # simulate the variable x and y
    x = np.random.rand(200, 7)
    y = np.random.rand(200, 2)

    # synergy between (0, 1, 2) and the first column of y
    y[:, 0] = x[:, 0] + x[:, 1] + x[:, 2]

    # redundancy between (3, 4, 5) and the second column of x
    x[:, 3] += y[:, 1]
    x[:, 4] += y[:, 1]
    x[:, 5] += y[:, 1]

    # define the RSI, launch it and inspect the best multiplets
    model = RSI(x, y)
    hoi = model.fit(minsize=3, maxsize=5)
    df = get_nbest_mult(hoi, model=model, minsize=3, maxsize=3, n_best=3)
    print(df)

    # plot the result at each order to observe the spreading at orders higher than
    # 3
    plot_landscape(
        hoi,
        model,
        kind="scatter",
        undersampling=False,
        plt_kwargs=dict(cmap="turbo"),
    )
    plt.show()



.. image-sg:: /auto_examples/metrics/images/sphx_glr_plot_rsi_001.png
   :alt: plot rsi
   :srcset: /auto_examples/metrics/images/sphx_glr_plot_rsi_001.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

      0%|          |  0/3 [00:00<?,       ?it/s]     33%|███▎      | RSI order 3:  1/3 [00:00<00:00,    3.74it/s]     67%|██████▋   | RSI order 4:  2/3 [00:00<00:00,    3.63it/s]    100%|██████████| RSI order 5:  3/3 [00:00<00:00,    3.70it/s]                                                                    index  order       hoi  multiplet
    0      0      3  1.585721  [0, 1, 2]
    1      2      3  0.209048  [0, 1, 4]
    2      3      3  0.200949  [0, 1, 5]
    3      9      3 -0.285303  [0, 3, 4]
    4     32      3 -0.287532  [3, 4, 6]
    5     31      3 -0.597655  [3, 4, 5]





.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 7.210 seconds)

**Estimated memory usage:**  51 MB


.. _sphx_glr_download_auto_examples_metrics_plot_rsi.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example




    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_rsi.py <plot_rsi.py>`

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_rsi.ipynb <plot_rsi.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
