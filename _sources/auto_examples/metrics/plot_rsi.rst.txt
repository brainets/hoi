
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples/metrics/plot_rsi.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_examples_metrics_plot_rsi.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_metrics_plot_rsi.py:


Redundancy-Synergy Index
========================

This example illustrates how to use and interpret the Redundancy-Synergy
Index (RSI).

.. GENERATED FROM PYTHON SOURCE LINES 8-17

.. code-block:: default

    import numpy as np

    from hoi.metrics import RSI
    from hoi.utils import get_nbest_mult
    from hoi.plot import plot_landscape

    import matplotlib.pyplot as plt









.. GENERATED FROM PYTHON SOURCE LINES 18-24

Definition
----------

The RSI is a multivariate measure of information capable of disentangling
whether a subset of a variable X carry either redundant or synergistic
information about a variable Y. The RSI is defined as :

.. GENERATED FROM PYTHON SOURCE LINES 26-36

.. math::
    RSI(S; Y) \equiv I(S; Y) - \sum_{x_{i}\in S} I(x_{i}; Y)

with :

.. math::
    S = x_{1}, ..., x_{n}

Positive values of RSI stand for synergy while negative values of RSI reflect
redundancy between the X and Y variables.

.. GENERATED FROM PYTHON SOURCE LINES 38-44

Simulate univariate redundancy
------------------------------

A very simple way to simulate redundancy is to observe that if a triplet of
variables :math:`X_{1}, X_{2}, X_{3}` receive a copy of a variable :math:`Y`,
we will observe redundancy between :math:`X_{1}, X_{2}, X_{3}` and :math:`Y`.

.. GENERATED FROM PYTHON SOURCE LINES 44-65

.. code-block:: default


    # lets start by simulating a variable x with 200 samples and 7 features
    x = np.random.rand(200, 7)

    # now we can also generate a univariate random variable y
    y = np.random.rand(x.shape[0])

    # we now send the variable y in the column (1, 3, 5) of x
    x[:, 1] += y
    x[:, 3] += y
    x[:, 5] += y

    # define the RSI model and launch it
    model = RSI(x, y)
    hoi = model.fit(minsize=3, maxsize=5)

    # now we can take a look at the multiplets with the highest and lowest values
    # of RSI. We will only select the multiplets of size 3 here
    df = get_nbest_mult(hoi, model=model, minsize=3, maxsize=3, n_best=3)
    print(df)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

      0%|          |  0/3 [00:00<?,       ?it/s]     33%|███▎      | RSI order 3:  1/3 [00:00<00:01,    1.46it/s]     67%|██████▋   | RSI order 4:  2/3 [00:01<00:00,    2.00it/s]    100%|██████████| RSI order 5:  3/3 [00:01<00:00,    2.13it/s]                                                                    index  order       hoi  multiplet
    0      0      3  0.032956  [0, 1, 2]
    1     16      3  0.031921  [1, 2, 4]
    2     18      3  0.027831  [1, 2, 6]
    3     31      3 -0.284001  [3, 4, 5]
    4     33      3 -0.286477  [3, 5, 6]
    5     20      3 -0.565875  [1, 3, 5]




.. GENERATED FROM PYTHON SOURCE LINES 66-68

as you see from the printed table, the multiplet with the lowest (i.e. the
most redundant multiplets) is (1, 3, 5).

.. GENERATED FROM PYTHON SOURCE LINES 70-75

Simulate multivariate redundancy
--------------------------------

In the example above, we simulated a univariate :math:`Y` variable (i.e.
single column). However, it's possible to simulate a multivariate variable.

.. GENERATED FROM PYTHON SOURCE LINES 75-97

.. code-block:: default


    # simulate x again
    x = np.random.rand(200, 7)

    # simulate a bivariate y variable
    y = np.c_[np.random.rand(x.shape[0]), np.random.rand(x.shape[0])]

    # we introduce redundancy between the triplet (1, 3, 5) and the first column of
    # Y and between (0, 2, 6) and Y
    x[:, 1] += y[:, 0]
    x[:, 3] += y[:, 0]
    x[:, 5] += y[:, 0]
    x[:, 0] += y[:, 1]
    x[:, 2] += y[:, 1]
    x[:, 6] += y[:, 1]

    # define the RSI, launch it and inspect the best multiplets
    model = RSI(x, y)
    hoi = model.fit(minsize=3, maxsize=5)
    df = get_nbest_mult(hoi, model=model, minsize=3, maxsize=3, n_best=3)
    print(df)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

      0%|          |  0/3 [00:00<?,       ?it/s]     33%|███▎      | RSI order 3:  1/3 [00:00<00:00,    2.15it/s]     67%|██████▋   | RSI order 4:  2/3 [00:00<00:00,    2.85it/s]    100%|██████████| RSI order 5:  3/3 [00:00<00:00,    3.18it/s]                                                                    index  order       hoi  multiplet
    0      9      3  0.012057  [0, 3, 4]
    1      2      3  0.009768  [0, 1, 4]
    2     12      3  0.005461  [0, 4, 5]
    3     29      3 -0.214735  [2, 4, 6]
    4     20      3 -0.378104  [1, 3, 5]
    5      8      3 -0.426096  [0, 2, 6]




.. GENERATED FROM PYTHON SOURCE LINES 98-100

This time, as expected, the two most redundant triplets are (1, 3, 5) and
(0, 2, 6)

.. GENERATED FROM PYTHON SOURCE LINES 102-109

Simulate univariate and multivariate synergy
--------------------------------------------

Lets move on to the simulation of synergy that is a bit more subtle. One way
of simulating synergy is to go the other way of redundancy, meaning we are
going to add features of x inside y. That way, we can only retrieve the Y
variable by knowing the subset of X.

.. GENERATED FROM PYTHON SOURCE LINES 109-122

.. code-block:: default


    # simulate the variable x
    x = np.random.rand(200, 7)

    # synergy between (0, 3, 5) and 5
    y = x[:, 0] + x[:, 3] + x[:, 5]

    # define the RSI, launch it and inspect the best multiplets
    model = RSI(x, y)
    hoi = model.fit(minsize=3, maxsize=5)
    df = get_nbest_mult(hoi, model=model, minsize=3, maxsize=3, n_best=3)
    print(df)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

      0%|          |  0/3 [00:00<?,       ?it/s]     33%|███▎      | RSI order 3:  1/3 [00:00<00:00,    2.76it/s]     67%|██████▋   | RSI order 4:  2/3 [00:00<00:00,    3.67it/s]    100%|██████████| RSI order 5:  3/3 [00:00<00:00,    4.12it/s]                                                                    index  order       hoi  multiplet
    0     10      3  1.402145  [0, 3, 5]
    1     26      3  0.267830  [2, 3, 5]
    2     33      3  0.263248  [3, 5, 6]
    3     24      3 -0.003083  [1, 5, 6]
    4     17      3 -0.003613  [1, 2, 5]
    5     22      3 -0.004108  [1, 4, 5]




.. GENERATED FROM PYTHON SOURCE LINES 123-126

as we can see here, the highest values of higher-order interactions
(i.e. synergy) is achieved for the multiplet (0, 3, 5). Now we can do the
same for multivariate synergy

.. GENERATED FROM PYTHON SOURCE LINES 126-140

.. code-block:: default


    # simulate the variable x
    x = np.random.rand(200, 7)

    # simulate y and introduce synergy between the subset (0, 3, 5) of x and the
    # subset (1, 2, 6)
    y = np.c_[x[:, 0] + x[:, 3] + x[:, 5], x[:, 1] + x[:, 2] + x[:, 6]]

    # define the RSI, launch it and inspect the best multiplets
    model = RSI(x, y)
    hoi = model.fit(minsize=3, maxsize=5)
    df = get_nbest_mult(hoi, model=model, minsize=3, maxsize=3, n_best=3)
    print(df)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

      0%|          |  0/3 [00:00<?,       ?it/s]     33%|███▎      | RSI order 3:  1/3 [00:00<00:00,    2.38it/s]     67%|██████▋   | RSI order 4:  2/3 [00:00<00:00,    3.19it/s]    100%|██████████| RSI order 5:  3/3 [00:00<00:00,    3.59it/s]                                                                    index  order       hoi  multiplet
    0     18      3  1.447543  [1, 2, 6]
    1     10      3  1.344808  [0, 3, 5]
    2      0      3  0.242070  [0, 1, 2]
    3     34      3 -0.008403  [4, 5, 6]
    4     28      3 -0.008716  [2, 4, 5]
    5     25      3 -0.014712  [2, 3, 4]




.. GENERATED FROM PYTHON SOURCE LINES 141-144

Combining redundancy and synergy
--------------------------------


.. GENERATED FROM PYTHON SOURCE LINES 144-173

.. code-block:: default


    # simulate the variable x and y
    x = np.random.rand(200, 7)
    y = np.random.rand(200, 2)

    # synergy between (0, 1, 2) and the first column of y
    y[:, 0] = x[:, 0] + x[:, 1] + x[:, 2]

    # redundancy between (3, 4, 5) and the second column of x
    x[:, 3] += y[:, 1]
    x[:, 4] += y[:, 1]
    x[:, 5] += y[:, 1]

    # define the RSI, launch it and inspect the best multiplets
    model = RSI(x, y)
    hoi = model.fit(minsize=3, maxsize=5)
    df = get_nbest_mult(hoi, model=model, minsize=3, maxsize=3, n_best=3)
    print(df)

    # plot the result at each order to observe the spreading at orders higher than
    # 3
    plot_landscape(
        hoi,
        model,
        kind="scatter",
        undersampling=False,
        plt_kwargs=dict(cmap="turbo"),
    )
    plt.show()



.. image-sg:: /auto_examples/metrics/images/sphx_glr_plot_rsi_001.png
   :alt: plot rsi
   :srcset: /auto_examples/metrics/images/sphx_glr_plot_rsi_001.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

      0%|          |  0/3 [00:00<?,       ?it/s]     33%|███▎      | RSI order 3:  1/3 [00:00<00:00,    2.30it/s]     67%|██████▋   | RSI order 4:  2/3 [00:00<00:00,    3.13it/s]    100%|██████████| RSI order 5:  3/3 [00:00<00:00,    3.55it/s]                                                                    index  order       hoi  multiplet
    0      0      3  1.692653  [0, 1, 2]
    1      6      3  0.273629  [0, 2, 4]
    2      8      3  0.251986  [0, 2, 6]
    3     20      3 -0.286211  [1, 3, 5]
    4     33      3 -0.288871  [3, 5, 6]
    5     31      3 -0.615239  [3, 4, 5]





.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 5.697 seconds)

**Estimated memory usage:**  53 MB


.. _sphx_glr_download_auto_examples_metrics_plot_rsi.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example




    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_rsi.py <plot_rsi.py>`

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_rsi.ipynb <plot_rsi.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
