
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples/metrics/plot_rsi.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_examples_metrics_plot_rsi.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_metrics_plot_rsi.py:


Redundancy-Synergy Index
========================

This example illustrates how to use and interpret the Redundancy-Synergy
Index (RSI).

.. GENERATED FROM PYTHON SOURCE LINES 8-17

.. code-block:: Python

    import numpy as np

    from hoi.metrics import RSI
    from hoi.utils import get_nbest_mult
    from hoi.plot import plot_landscape

    import matplotlib.pyplot as plt









.. GENERATED FROM PYTHON SOURCE LINES 18-24

Definition
----------

The RSI is a multivariate measure of information capable of disentangling
whether a subset of a variable X carry either redundant or synergistic
information about a variable Y. The RSI is defined as :

.. GENERATED FROM PYTHON SOURCE LINES 26-36

.. math::
    RSI(S; Y) \equiv I(S; Y) - \sum_{x_{i}\in S} I(x_{i}; Y)

with :

.. math::
    S = x_{1}, ..., x_{n}

Positive values of RSI stand for synergy while negative values of RSI reflect
redundancy between the X and Y variables.

.. GENERATED FROM PYTHON SOURCE LINES 38-44

Simulate univariate redundancy
------------------------------

A very simple way to simulate redundancy is to observe that if a triplet of
variables :math:`X_{1}, X_{2}, X_{3}` receive a copy of a variable :math:`Y`,
we will observe redundancy between :math:`X_{1}, X_{2}, X_{3}` and :math:`Y`.

.. GENERATED FROM PYTHON SOURCE LINES 44-65

.. code-block:: Python


    # lets start by simulating a variable x with 200 samples and 7 features
    x = np.random.rand(200, 7)

    # now we can also generate a univariate random variable y
    y = np.random.rand(x.shape[0])

    # we now send the variable y in the column (1, 3, 5) of x
    x[:, 1] += y
    x[:, 3] += y
    x[:, 5] += y

    # define the RSI model and launch it
    model = RSI(x, y)
    hoi = model.fit(minsize=3, maxsize=5)

    # now we can take a look at the multiplets with the highest and lowest values
    # of RSI. We will only select the multiplets of size 3 here
    df = get_nbest_mult(hoi, model=model, minsize=3, maxsize=3, n_best=3)
    print(df)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

      0%|          |  0/3 [00:00<?,       ?it/s]     33%|███▎      | RSI order 3:  1/3 [00:00<00:01,    1.79it/s]     67%|██████▋   | RSI order 4:  2/3 [00:00<00:00,    2.41it/s]    100%|██████████| RSI order 5:  3/3 [00:01<00:00,    2.57it/s]                                                                    index  order       hoi  multiplet
    0      7      3  0.003867  [0, 2, 5]
    1      0      3  0.001549  [0, 1, 2]
    2      6      3  0.000447  [0, 2, 4]
    3     33      3 -0.255845  [3, 5, 6]
    4     31      3 -0.260604  [3, 4, 5]
    5     20      3 -0.480741  [1, 3, 5]




.. GENERATED FROM PYTHON SOURCE LINES 66-68

as you see from the printed table, the multiplet with the lowest (i.e. the
most redundant multiplets) is (1, 3, 5).

.. GENERATED FROM PYTHON SOURCE LINES 70-75

Simulate multivariate redundancy
--------------------------------

In the example above, we simulated a univariate :math:`Y` variable (i.e.
single column). However, it's possible to simulate a multivariate variable.

.. GENERATED FROM PYTHON SOURCE LINES 75-97

.. code-block:: Python


    # simulate x again
    x = np.random.rand(200, 7)

    # simulate a bivariate y variable
    y = np.c_[np.random.rand(x.shape[0]), np.random.rand(x.shape[0])]

    # we introduce redundancy between the triplet (1, 3, 5) and the first column of
    # Y and between (0, 2, 6) and Y
    x[:, 1] += y[:, 0]
    x[:, 3] += y[:, 0]
    x[:, 5] += y[:, 0]
    x[:, 0] += y[:, 1]
    x[:, 2] += y[:, 1]
    x[:, 6] += y[:, 1]

    # define the RSI, launch it and inspect the best multiplets
    model = RSI(x, y)
    hoi = model.fit(minsize=3, maxsize=5)
    df = get_nbest_mult(hoi, model=model, minsize=3, maxsize=3, n_best=3)
    print(df)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

      0%|          |  0/3 [00:00<?,       ?it/s]     33%|███▎      | RSI order 3:  1/3 [00:00<00:00,    2.56it/s]     67%|██████▋   | RSI order 4:  2/3 [00:00<00:00,    3.34it/s]    100%|██████████| RSI order 5:  3/3 [00:00<00:00,    3.74it/s]                                                                    index  order       hoi  multiplet
    0     28      3  0.014415  [2, 4, 5]
    1      2      3  0.010106  [0, 1, 4]
    2     12      3  0.008868  [0, 4, 5]
    3     13      3 -0.287546  [0, 4, 6]
    4     20      3 -0.463497  [1, 3, 5]
    5      8      3 -0.582765  [0, 2, 6]




.. GENERATED FROM PYTHON SOURCE LINES 98-100

This time, as expected, the two most redundant triplets are (1, 3, 5) and
(0, 2, 6)

.. GENERATED FROM PYTHON SOURCE LINES 102-109

Simulate univariate and multivariate synergy
--------------------------------------------

Lets move on to the simulation of synergy that is a bit more subtle. One way
of simulating synergy is to go the other way of redundancy, meaning we are
going to add features of x inside y. That way, we can only retrieve the Y
variable by knowing the subset of X.

.. GENERATED FROM PYTHON SOURCE LINES 109-122

.. code-block:: Python


    # simulate the variable x
    x = np.random.rand(200, 7)

    # synergy between (0, 3, 5) and 5
    y = x[:, 0] + x[:, 3] + x[:, 5]

    # define the RSI, launch it and inspect the best multiplets
    model = RSI(x, y)
    hoi = model.fit(minsize=3, maxsize=5)
    df = get_nbest_mult(hoi, model=model, minsize=3, maxsize=3, n_best=3)
    print(df)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

      0%|          |  0/3 [00:00<?,       ?it/s]     33%|███▎      | RSI order 3:  1/3 [00:00<00:00,    3.30it/s]     67%|██████▋   | RSI order 4:  2/3 [00:00<00:00,    4.37it/s]    100%|██████████| RSI order 5:  3/3 [00:00<00:00,    4.89it/s]                                                                    index  order       hoi  multiplet
    0     10      3  1.437647  [0, 3, 5]
    1      3      3  0.237620  [0, 1, 5]
    2      7      3  0.234368  [0, 2, 5]
    3     15      3 -0.001121  [1, 2, 3]
    4     27      3 -0.003464  [2, 3, 6]
    5     25      3 -0.003558  [2, 3, 4]




.. GENERATED FROM PYTHON SOURCE LINES 123-126

as we can see here, the highest values of higher-order interactions
(i.e. synergy) is achieved for the multiplet (0, 3, 5). Now we can do the
same for multivariate synergy

.. GENERATED FROM PYTHON SOURCE LINES 126-140

.. code-block:: Python


    # simulate the variable x
    x = np.random.rand(200, 7)

    # simulate y and introduce synergy between the subset (0, 3, 5) of x and the
    # subset (1, 2, 6)
    y = np.c_[x[:, 0] + x[:, 3] + x[:, 5], x[:, 1] + x[:, 2] + x[:, 6]]

    # define the RSI, launch it and inspect the best multiplets
    model = RSI(x, y)
    hoi = model.fit(minsize=3, maxsize=5)
    df = get_nbest_mult(hoi, model=model, minsize=3, maxsize=3, n_best=3)
    print(df)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

      0%|          |  0/3 [00:00<?,       ?it/s]     33%|███▎      | RSI order 3:  1/3 [00:00<00:00,    2.84it/s]     67%|██████▋   | RSI order 4:  2/3 [00:00<00:00,    3.80it/s]    100%|██████████| RSI order 5:  3/3 [00:00<00:00,    4.28it/s]                                                                    index  order       hoi  multiplet
    0     10      3  1.479057  [0, 3, 5]
    1     18      3  1.458830  [1, 2, 6]
    2      5      3  0.263525  [0, 2, 3]
    3     34      3 -0.002007  [4, 5, 6]
    4     13      3 -0.006625  [0, 4, 6]
    5     22      3 -0.008204  [1, 4, 5]




.. GENERATED FROM PYTHON SOURCE LINES 141-144

Combining redundancy and synergy
--------------------------------


.. GENERATED FROM PYTHON SOURCE LINES 144-173

.. code-block:: Python


    # simulate the variable x and y
    x = np.random.rand(200, 7)
    y = np.random.rand(200, 2)

    # synergy between (0, 1, 2) and the first column of y
    y[:, 0] = x[:, 0] + x[:, 1] + x[:, 2]

    # redundancy between (3, 4, 5) and the second column of x
    x[:, 3] += y[:, 1]
    x[:, 4] += y[:, 1]
    x[:, 5] += y[:, 1]

    # define the RSI, launch it and inspect the best multiplets
    model = RSI(x, y)
    hoi = model.fit(minsize=3, maxsize=5)
    df = get_nbest_mult(hoi, model=model, minsize=3, maxsize=3, n_best=3)
    print(df)

    # plot the result at each order to observe the spreading at orders higher than
    # 3
    plot_landscape(
        hoi,
        model,
        kind="scatter",
        undersampling=False,
        plt_kwargs=dict(cmap="turbo"),
    )
    plt.show()



.. image-sg:: /auto_examples/metrics/images/sphx_glr_plot_rsi_001.png
   :alt: plot rsi
   :srcset: /auto_examples/metrics/images/sphx_glr_plot_rsi_001.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

      0%|          |  0/3 [00:00<?,       ?it/s]     33%|███▎      | RSI order 3:  1/3 [00:00<00:00,    2.81it/s]     67%|██████▋   | RSI order 4:  2/3 [00:00<00:00,    3.80it/s]    100%|██████████| RSI order 5:  3/3 [00:00<00:00,    4.30it/s]                                                                    index  order       hoi  multiplet
    0      0      3  1.550729  [0, 1, 2]
    1     15      3  0.208810  [1, 2, 3]
    2      8      3  0.206445  [0, 2, 6]
    3      9      3 -0.234210  [0, 3, 4]
    4     10      3 -0.234260  [0, 3, 5]
    5     31      3 -0.509647  [3, 4, 5]





.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 4.908 seconds)

**Estimated memory usage:**  55 MB


.. _sphx_glr_download_auto_examples_metrics_plot_rsi.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_rsi.ipynb <plot_rsi.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_rsi.py <plot_rsi.py>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
